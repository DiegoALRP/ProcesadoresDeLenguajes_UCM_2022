
  
  Prog Init()    : {Prog prog;} {prog=Prog() <EOF> {return prog;}}
  Prog Prog()    : {Exp exp; Decs decs;} 
                    {<evalua> exp=E0() decs=PDonde() {return sem.prog(exp,decs);}}
  Decs PDonde()  : {Decs decs;} 
                       {<donde> decs=Decs() {return decs;} | 
                       {return null;}}
  Exp E0()       : {Exp exp1, resul;} {exp1=E1() resul=RE0(exp1) {return resul;}}
  Exp RE0(Exp exph) : {char op; Exp exp1; Exp exp;} 
                       {op=OP0() exp1=E2() exp=RE0(sem.exp(op,exph,exp1)) {return exp;} |
                       {return exph;}}
  Exp E1()       : {Exp exp2, resul;} {exp2=E2() resul=RE1(exp2) {return resul;}}
  Exp RE1(Exp exph) : {char op; Exp exp2; Exp exp;} 
                       {op=OP1() exp2=E2() exp=RE1(sem.exp(op,exph,exp2)) {return exp;} |
                       {return exph;}}
  Exp E2()         : {Exp exp; Token t;}  
                        {t=<num> {return sem.num(sem.str(t.image,t.beginLine,t.beginColumn));} |
                         t=<id>  {return sem.id(sem.str(t.image,t.beginLine,t.beginColumn));} |
						"(" exp=E0() ")" {return exp;}}
  char OP0() : {} {"+" {return '+';} |
                   "-" {return '-';}}						
  char OP1() : {} {"*" {return '*';} |
                   "/" {return '/';}}
  Decs Decs() : {Dec dec; Decs decs;} {dec=Dec() decs=RDecs(sem.decs_una(dec)) {return decs;}}
  Decs RDecs(Decs decsh) : {Dec dec; Decs decs;} 
                             {"," dec=Dec() decs=RDecs(sem.decs_muchas(decsh,dec)) {return decs;} |
                             {return decsh;}}
  Dec Dec() : {Token iden,numb;} {iden=<id> "=" numb=<num> 
                                    {return sem.dec(sem.str(iden.image,iden.beginLine,iden.beginColumn),
                                                    sem.str(numb.image,numb.endLine,numb.endColumn));}}		
                                                    			 
-------------------------------------------------------
options  {
  STATIC=false;
}  
PARSER_BEGIN(ConstructorAST)
package c_ast_descendente;

import asint.TinyASint.Exp;
import asint.TinyASint.Dec;
import asint.TinyASint.Decs;
import asint.TinyASint.Prog;
import semops.SemOps;

public class ConstructorAST {
   private SemOps sem = new SemOps();
}
PARSER_END(ConstructorAST)

  TOKEN: {<#letra:["a"-"z","A"-"Z"]>}
  TOKEN: {<#digitoPositivo:["1"-"9"]>}
  TOKEN: {<#digito:<digitoPositivo>|"0">}
  TOKEN: {<#parteEntera:<digitoPositivo> (<digito>)* |"0">} 
  TOKEN: {<#parteDecimal: (<digito>)* <digitoPositivo> | "0">}
  TOKEN: {<#parteExponencial: ["e","E"] <numeroEntero>>}
  SKIP: {<["\t"," ","\r","\b","\n"]>}  
  SKIP: {<"#"(~["\n"])*>}
  TOKEN: {<ent: "int">}
  TOKEN: {<real: "real">}
  TOKEN: {<bool: "bool">}
  TOKEN: {<True: "true">}
  TOKEN: {<False: "false">}
  TOKEN: {<and: "and">}
  TOKEN: {<or: "or">}
  TOKEN: {<not: "not">}
  TOKEN: {<string: "string">}
  TOKEN: {<Null: "null">}
  TOKEN: {<procedimiento: "proc">}
  TOKEN: {<If: "if">}
  TOKEN: {<Then: "then">}
  TOKEN: {<Else: "else">}
  TOKEN: {<endif: "endif">}
  TOKEN: {<While: "while">}
  TOKEN: {<Do: "do">}
  TOKEN: {<endwhile: "endwhile">}
  TOKEN: {<call: "call">}
  TOKEN: {<record: "record">}
  TOKEN: {<array: "array">}
  TOKEN: {<of: "of">}
  TOKEN: {<pointer: "pointer">}
  TOKEN: {<New: "new">}
  TOKEN: {<delete: "delete">}
  TOKEN: {<read: "read">}
  TOKEN: {<write: "write">}
  TOKEN: {<nl: "nl">}
  TOKEN: {<var: "var">}
  TOKEN: {<type: "type">}
  TOKEN: {<lit_cadena: "\""(~["\b", "\n", "\r"])*"\"">}
  TOKEN: {<numeroEntero: (["+","-"])? <parteEntera> >}
  TOKEN: {<numeroReal: (["+","-"])? <parteEntera> ("." <parteDecimal> | <parteExponencial> | "." <parteDecimal> <parteExponencial> ) >}
  TOKEN: {<iden: <letra>(<letra>|<digito>|"_")*>}

  Prog Ini()           						: {Prog prog;} 
  																			{prog = Programa() <EOF>{return prog;}}
  Prog Programa()      						: {SDec sdec; SInst sinst;} 
  																			{sdec = OPDec() sinst = SInst() {return sem.prog(sdec,sinst));}}
  OPDec OPDec()         					: {SDec sdec;} 
  																			{sdec = SDec() "&""&" {return sdec;}| {return null;}}
  SDec SDec()          						: {SDec dec, resul;}
  																			{dec = sdec_una(Dec())  resul = RSDec(dec) {return resul;}}
  SDec RSDec(SDec decah)    				: {SDec rsdecah, resul; Dec dec;}		
  																			{ ";" rsdecah = sem.sdec_muchas(decah, dec) resul = RSDec(dec) {return resul;} | { return decah; } }
  Dec Dec()           						: {TipoVar tipo; Token t; ParamFormales param; Bloque bloq;} 
  																			{<var> tipo=TipoVar() t=<iden>) {return sem.dec_var(tipo, sem.str(t.lexema, t.fila(), t.columna()));}
  																			| <type> tipo=TipoVar() t=<iden> {return sem.dec_type(tipo,sem.str(t.lexema, t.fila(), t.columna()) );}
						| <procedimiento> t=<iden> "("param=ParamFormales()")" "{"bloq = Bloque()"}" {return sem.dec_proc( sem.str(t.lexema, t.fila(), t.columna()),param, bloq);}}
  TipoVar TipoVar()       					: {Token t; TipoVar tipo; ListaCampos campos;} 
  																			{ <ent> {return tipoVar("int");} | <real> { return tipoVar("real");} | <bool>{ return tipoVar("bool");} 
  																			| <string> {return tipoVar("string"); }| t=<iden> {return tipoVar_iden(sem.str(t.lexema, t.fila(), t.columna()) ); } 
																			| <pointer> tipo=TipoVar() {return  tipoVar_pointer(tipo);} 
							  						| <array> "["t=<numeroEntero>"]" <of> tipo=TipoVar() {return tipoVar_array( sem.str(t.lexema, t.fila(), t.columna()), tipo);}  
							  						| <record> "{" camposListaCampos() "}" {return tipoVar_array(campos); }}
  ListaCampo ListaCampos()   						: {Campo rlistacampoah; ListaCampos resul;} 
  																			{rlistacampoah=Campo() resul=RListaCampos(listaCampos_uno(rlistacampoah)) {return resul;}}
  ListaCampo RListaCampos(Campo rlistacampoah0)  		: {Campo rlistacampoah1; ListaCampos resul;} 
  											{ ";" rlistacampoah1= sem.listaCampos_muchos(rlistacampoah0,Campo()) resul=RListaCampos() {return resul;}| {return rlistacampoah0;} }
  Campo Campo()         						: {Token t; TipoVar tipo;} 
  																			{ tipo=TipoVar() t=<iden> {returnsem.campo(tipo,sem.str(t.lexema, t.fila(), t.columna()))}}
  ParamFormales ParamFormales() 						: {ListaParam lista;} 
  																			{ lista=ListaParam() {return lista;} | { return null;}}
  ListaParam ListaParam()    						: {Param paramah; ListaParam resul;} 
  																			{ paramah = Param()resul=RListaParam(lista_param_uno(paramah)){return resul}}
  RListaParam RListaParam(ListaParama paramah0)   	: {ListaParam paramah1; ListaParam resul;} 
  																			{ "," paramah1=lista_param_muchos(paramah0,Param()) {resul=RListaParam(paramah1);} 
																			| {return paramah0;}}
  Param Param()         						: {TipoVar rparamah; Param resul;} 
  																			{rparamah=TipoVar() resul=RParam(rparamah) {return resul;}}
  RParam RParam(TipoVar rparamah)        		: { Token t;} 
  																			{ "&" t=<iden> {return param_amps(rparamah,sem.str(t.lexema, t.fila(), t.columna())) } 
  																| t=<iden> return param_normal(sem.str(t.lexema, t.fila(), t.columna(),sem.str(t.lexema, t.fila(), t.columna()))}
  Bloque Bloque()        						: {Programa resultado;} 
  																			{ resultado=Programa() {return sem.bloque_con(resultado);} | {return null;}}
  SInst SInst()         						: {Inst inst, SInst resultado;} 
  																			{inst=Inst() resultado=RInst(sem.sints_uno(inst)) {return resultado;}}
  SInst RInst(SInst rinstH)   					: {Inst inst; SInst rinst;} { ";" inst=Inst() rinst=RInst(rinstH, inst) | {return null;}}
  Inst Inst()          							: {Exp exp0, exp01, exp02; SInst sinst; Else else; ParamReales paramReales; Token iden; Bloque bloque;} 
  																			{ exp01=E0() "=" exp02=E0() {return sem.inst_asig(exp01, exp02);} 
																			| <If> exp0=E0() <Then> sints=SInst() else=Else() <endif> {return sem.inst_inf(exp0, sinst, else);} 
																			| <While> exp0=E0() <Do> sinst=SInst() <endwhile> {return sem.inst_while(exp0, sinst);} 
																			| <read> exp0=E0() {return sem.inst_read(exp0);} 
																			| <write> exp0=E0() {return sem.inst_write(exp0);} 
																			| <nl> {return sem.inst_nl("nl")} 
																			| <New> exp0=E0() {return sem.inst_new(exp0);} 
																			| <delete> exp0=E0() {return sem.inst_delete(exp0);} 
																			| <call> iden=<iden> "(" paramReales=ParamReales()")" {return sem.inst_call(iden.lexema(), iden.fila(), iden.columna());} 
																			| "{" bloque=Bloque()"}" {return sem.inst_bloque(bloque);}} 
  Else Else()          							: {SInst sinst;} 
  																			{ <Else> sinst=SInst() {return sem.else_muchos(sinst);} | {return null;}} 
  ParamReales ParamReales()    					: {RParamReales resultado; Exp exp0;} 
  																			{ exp0=E0() resultado=RParamReales(sem.param_reales_uno(exp0)) {return resultado;} | {return null;}}
  RParamReales RParamReales(RParamReales rpaH)  : {Exp exp0; RParamReales resultado;} 
  																{ "," exp0=E0() resultado=RParamReales(sem.param_reales_muchos(rpaH, exp0)) {return resultado;} | {} {return rpaH;}}
  Exp E0()            							: {Exp exp1, resultado;} 
  																			{exp1 = E1() resultado = RE0(exp1) {return resultado;}}
  Exp RE0(Exp expH)   							: {Exp exp0; Exp exp1; String operation;} 
  																			{ "+" exp0 = E0() {return sem.suma(expH, exp0);} 
																			| "-" exp1=E1() {return sem.resta(expH, exp1);} 
																			| {return expH;}}
  Exp E1()            							: {Exp exp2, resultado;} 
  																			{exp2=E2() resultado=RE1(exp2) {return resultado;}}
  Exp RE1(Exp expH)   							: {String operation; Exp exp2, resultado;} 
  																{operation=OP1AI() exp2=E2() resultado=RE1(sem.exp(operation, expH, exp2)) {return resultado;} | {return expH;}}
  Exp E2()            							: {Exp exp3, resultado;} 
  																			{exp3=E3() resultado=RE2(exp3) {return resultado;}}
  Exp RE2(Exp expH)   							: {String operation; Exp exp3, resultado;} 
  																{operation=OP2AI() exp3=E3() resultado=RE2(sem.exp(operation, expH, exp3)) {return resultado;} | {return expH;}}
  Exp E3()            							: {Exp exp4, resultado;} 
  																			{exp4=E4() resultado=RE3(exp4) {return resultado;}}
  Exp RE3(Exp expH)                             : {String operation; Exp exp4, resultado;} 
                                                                	{operation=OP3NA() exp4=E4() resultado=sem.exp(operation, expH, exp4) {return resultado;} | {return expH;}}
  Exp E4()            							: {Exp exp4, exp5, resultado;} 
  																			{ "-" exp5=E5() resultado=sem.negativoOperation(exp5) {return resultado;} 
																			| <not> exp4=E4() resultado=sem.notOperation(exp4) {return resultado;} 
																			| exp5=E5() {return exp5;}}
  Exp E5()            							: {Exp exp6, resultado;} 
  																			{exp6=E6() RRE5() | RE5() RRE5()| {return null;}}
  Exp RRE5(Exp rre5H)									: {Exp re5, resultado;}
																			{ re5=RE5(rre5H) resultado=RRE5(re5) {return resultado;} | {return rre5H;}}
  Exp RE5(Exp expH)           					: {String operation; Exp exp0; Token iden;} 
  																			{ "[" exp0=E0() "]" {return sem.array_op(expH, exp0);} 
																			| operation=OP5A() iden=<iden> {return sem.exp(operation, expH, iden.lexema(), iden.fila, iden.columna());}}
  Exp E6()            							: {Exp exp6, exp7;} 
  																			{"*" exp6=E6() {return sem.pointer_ast(exp6);} | exp7=E7() {return exp7;}}
  Exp E7()                              		: {Token t; Exp exp0;} 
  																			{ <True> {return "true";} | <False> {return "false";} 
																			| t=<numeroEntero> {return sem.entero(sem.str(t.lexema(), t.fila(), t.columna()));} 
																			| t=<numeroReal> {return sem.real(sem.str(t.lexema(), t.fila(), t.columna()));} 
																			| t=<lit_cadena> {return sem.lit_cadena(sem.str(t.lexema(), t.fila(), t.columna()));}
																			| <Null> {return sem.nulo("null");} | "(" exp0=E0() ")" {return exp0;} 
																			| t=<iden> {return sem.identificador(t.lexema(), t.fila(), t.columna());}}
  String OP1AI()         						: {} 
  																			{ <and> {return "and";} | <or> {return "or";}}
  String OP2AI()         						: {} 
  																			{ ">" {return ">";} | "<" {return "<";} | "<=" {return "<=";} | ">=" {return ">=";} 
																			| "==" {return "==";} | "!=" {return "!=";} }
  String OP3NA()         						: {} 
  																			{ "*" {return "*";} | "/" {return "/";} | "%" {return "%";} }
  String OP5A()          						: {} 
  																			{ "." return "." | "->" {return "->"} }